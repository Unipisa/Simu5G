[General]
image-path=../../../images
output-scalar-file-append = false
**.routingRecorder.enabled = false

**.cmdenv-log-level = off

############### Statistics ##################
output-scalar-file = ${resultdir}/${configname}/${configname}-${iterationvars}-${repetition}.sca
output-vector-file = ${resultdir}/${configname}/${configname}-${iterationvars}-${repetition}.vec
seed-set = ${repetition}
num-rngs = 5
repeat = 1

**.sctp.**.scalar-recording = false  # remove annoying statistics from SCTP
**.sctp.**.vector-recording = false  # remove annoying statistics from SCTP

**.ue*[*].vector-recording = true
**.vector-recording = true

############### SCTP configuration ##################
**.sctp.nagleEnabled = false         # if true, transmission of small packets will be delayed on the X2
**.sctp.enableHeartbeats = false

############### General PHY parameters ##############
**.downlink_interference = true
**.uplink_interference = true
**.ueTxPower = 26
**.eNodeBTxPower = 46
**.targetBler = 0.01
**.blerShift = 5  
**.fbPeriod = 40   # reports CQI every 40ms

############### IPv4 configurator config #################
*.configurator.config = xmldoc("./demo.xml")

# ------------------------------------------------------------------------ #
# Config MultiOperator
#
# General configuration for the multicell, multi-operator system
# Also see 'demo.xml' for the correct configuration of network interfaces 
#
[Config MultiOperator]
description = "Base configuration, do not run this config!"
sim-time-limit= 60s
network = simu5g.simulations.NR.mec.platooning.MultiOperator

############# Floorplan parameters ################
**.mobility.constraintAreaMaxX = 2700m
**.mobility.constraintAreaMaxY = 1550m
**.mobility.constraintAreaMinX = 0m
**.mobility.constraintAreaMinY = 250m
**.mobility.constraintAreaMinZ = 0m
**.mobility.constraintAreaMaxZ = 0m
**.mobility.initFromDisplayString = false

############### CA configuration ################# 
# we configure two carrier components: operator A uses CC 0, while operator B uses CC 1
*.carrierAggregation.numComponentCarriers = 2
*.carrierAggregation.componentCarrier[0].numerologyIndex = 0 # ${u=0}
*.carrierAggregation.componentCarrier[0].carrierFrequency = 2GHz
*.carrierAggregation.componentCarrier[0].numBands = 50 #${numRbs=50}
*.carrierAggregation.componentCarrier[1].numerologyIndex = 0 #${u}
*.carrierAggregation.componentCarrier[1].carrierFrequency = 4GHz
*.carrierAggregation.componentCarrier[1].numBands = 50 #${numRbs}

*.gnb*.cellularNic.numCarriers = 1
*.ue_*[*].cellularNic.numCarriers = 1

*.gnb_A*.cellularNic.channelModel[0].componentCarrierIndex = 0
*.gnb_B*.cellularNic.channelModel[0].componentCarrierIndex = 1
*.ue_A[*].cellularNic.nrChannelModel[0].componentCarrierIndex = 0
*.ue_B[*].cellularNic.nrChannelModel[0].componentCarrierIndex = 1
**.cellularNic.LteChannelModelType = "NRChannelModel_3GPP38_901"

############### BS position #################
# operator A's and B's gNBs are co-located
*.gnb_*.mobility.initialY = 500m
#*.gnb_B*.mobility.initialY = 520m
*.gnb_*1.mobility.initialX = 250m
*.gnb_*2.mobility.initialX = 750m
*.gnb_*3.mobility.initialX = 1250m
*.gnb_*4.mobility.initialX = 1750m

############## BS gateway ##################
*.gnb_A*.gateway = "upf_A"
*.gnb_B*.gateway = "upf_B"

############### X2 configuration #################
*.gnb_*2.numX2Apps = 2                                        # one x2App per peering node
*.gnb_*3.numX2Apps = 2                                        # one x2App per peering node
*.gnb*.numX2Apps = 1                                          # one x2App per peering node
*.gnb*.x2App[*].server.localPort = 5000 + ancestorIndex(1)  # Server ports (x2App[0]=5000, x2App[1]=5001, ...)
*.gnb_A1.x2App[0].client.connectAddress = "gnb_A2%x2ppp0" 
*.gnb_A2.x2App[0].client.connectAddress = "gnb_A1%x2ppp0" 
*.gnb_A2.x2App[1].client.connectAddress = "gnb_A3%x2ppp0" 
*.gnb_A3.x2App[0].client.connectAddress = "gnb_A2%x2ppp1" 
*.gnb_A3.x2App[1].client.connectAddress = "gnb_A4%x2ppp0"
*.gnb_A4.x2App[0].client.connectAddress = "gnb_A3%x2ppp1"
 

*.gnb_B1.x2App[0].client.connectAddress = "gnb_B2%x2ppp0" 
*.gnb_B2.x2App[0].client.connectAddress = "gnb_B1%x2ppp0" 
*.gnb_B2.x2App[1].client.connectAddress = "gnb_B3%x2ppp0" 
*.gnb_B3.x2App[0].client.connectAddress = "gnb_B2%x2ppp1" 
*.gnb_B3.x2App[1].client.connectAddress = "gnb_B4%x2ppp0" 
*.gnb_B4.x2App[0].client.connectAddress = "gnb_B3%x2ppp1" 


################## UE configuration ##################
*.numUe_A = 3
*.numUe_B = 4

# UEs associates to the best BS at the beginning of the simulation
*.ue*[*].macCellId = 0
*.ue*[*].masterId = 0
*.ue_A[*].nrMacCellId = 1
*.ue_A[*].nrMasterId = 1
*.ue_B[*].nrMacCellId = 5
*.ue_B[*].nrMasterId = 5
**.dynamicCellAssociation = true
**.enableHandover = true

############ UEs position #################
*.ue*[*].mobility.typename = "LinearAccelerationMobility"
*.ue_A[0].mobility.initialX = 310m
*.ue_A[1].mobility.initialX = 300m
*.ue_A[2].mobility.initialX = 290m
*.ue_A[3].mobility.initialX = 285m
*.ue_B[0].mobility.initialX = 280m
*.ue_B[1].mobility.initialX = 270m
*.ue_B[2].mobility.initialX = 260m
*.ue_B[3].mobility.initialX = 250m


*.ue*[*].mobility.initialY = 600m
*.ue*[*].mobility.speed = 25mps# uniform(22mps, 24mps)
*.ue*[*].mobility.initialMovementHeading = 0deg


############ MEC Configuration ############
**.hasRNISupport = false

# tcp settings
**.tcp.typename = "Tcp"
**.tcp.advertisedWindow = 65535         # in bytes, corresponds with the maximal receiver buffer capacity (Note: normally, NIC queues should be at least this size)
**.tcp.tcpAlgorithmClass = "TcpReno"    # TcpReno/TcpTahoe/TcpNewReno/TcpNoCongestionControl/DumbTcp
**.tcp.sackSupport = true               # Selective Acknowledgment (RFC 2018, 2883, 3517) support (header option) (SACK will be enabled for a connection if both endpoints support it)

# MEC Hosts
**.mecHost*.virtualisationInfrastructure.ipv4.forwarding = true
*.mecHost*.maxMECApps = 100					# max ME Apps to instantiate
*.mecHost*.maxRam = 32GB					# max KBytes of Ram 
*.mecHost*.maxDisk = 100TB					# max KBytes of Disk Space 
*.mecHost*.maxCpuSpeed = 400000		    	# max CPU
*.mecHost_A*.gateway = "upf_A"
*.mecHost_B*.gateway = "upf_B"

# MEC Services
# MEC host 1 services configurations
*.mecHost*.mecPlatform.numMecServices = 1
*.mecHost*.mecPlatform.mecService[0].typename = "LocationService"
*.mecHost_A.mecPlatform.mecService[0].localAddress = "mecHost_A.virtualisationInfrastructure"
*.mecHost_B.mecPlatform.mecService[0].localAddress = "mecHost_B.virtualisationInfrastructure"
*.mecHost*.mecPlatform.mecService[0].localPort = 10020
*.mecHost_A.mecPlatform.serviceRegistry.localAddress = "mecHost_A.virtualisationInfrastructure"
*.mecHost_B.mecPlatform.serviceRegistry.localAddress = "mecHost_B.virtualisationInfrastructure"
*.mecHost*.mecPlatform.serviceRegistry.localPort = 10021

# random number generators configuration
*.mecHost_A.mecPlatform.mecService[0].rng-0 = 1 # request service time
*.mecHost_A.mecPlatform.mecService[0].rng-1 = 2 # subscription service time

*.mecHost_B.mecPlatform.mecService[0].rng-0 = 3 # request service time
*.mecHost_B.mecPlatform.mecService[0].rng-1 = 4 # subscription service time

*.mecHost*.mecPlatform.mecService[0].subscriptionServiceTime = 11us
*.mecHost*.mecPlatform.mecService[0].requestServiceTime = 0.5ms


# MEC Orchestrator & UALCMP configuration
*.mecOrchestrator_A.mecHostList = "mecHost_A"              # MEC hosts associated to the MEC system
*.mecOrchestrator_B.mecHostList = "mecHost_B"              # MEC hosts associated to the MEC system
*.mecOrchestrator*.mecApplicationPackageList = "PlatooningConsumerApp"   # List of MEC app descriptors to be onboarded at 
*.mecHost_A.mecPlatformManager.mecOrchestrator = "mecOrchestrator_A" # the MECPM needs to know the MEC orchestrator
*.mecHost_B.mecPlatformManager.mecOrchestrator = "mecOrchestrator_B" # the MECPM needs to know the MEC orchestrator
*.ualcmp_A.mecOrchestratorHostname = "mecOrchestrator_A"
*.ualcmp_B.mecOrchestratorHostname = "mecOrchestrator_B"
*.ualcmp_A.gateway = "upf_A"
*.ualcmp_B.gateway = "upf_B"


# MEC Platooning Provider App
**.numIndependentMecApp = 1
*.mecHost_*.independentMecApp[0].typename = "MECPlatooningProducerApp"
*.mecHost_*.independentMecApp[0].platooningConsumerAppsPort = 5500
*.mecHost_*.independentMecApp[0].platooningProducerAppsPort = 8500
*.mecHost_A.independentMecApp[0].producerAppId = 0
*.mecHost_B.independentMecApp[0].producerAppId = 1
*.mecHost_*.independentMecApp[0].controller = "rajamani" # ${controller = "rajamani", "safe"}

*.mecHost_*.independentMecApp[0].mecAppIndex = -1 #not relevant for independentMecApps 

*.mecHost_*.independentMecApp[0].mecAppId = 5500
*.mecHost_A.independentMecApp[*].mp1Address= "mecHost_A.virtualisationInfrastructure"
*.mecHost_B.independentMecApp[*].mp1Address= "mecHost_B.virtualisationInfrastructure"
*.mecHost_*.independentMecApp[*].mp1Port = 10021

**.independentMecApp[0].requiredRam = 10MB
**.independentMecApp[0].requiredDisk = 10MB
**.independentMecApp[0].requiredCpu = 1000 #MIPS


# ----------------------------------------------------------------------------------------------------- #
# MultiOperator_MultiMec
#
# In this configuration, UEs connected to operator A's network communicate with operator A's MEC Host, 
#  whereas UEs connected to operator B's network communicate with operator B's MEC host
#
[Config MultiOperator_MultiMec]
extends=MultiOperator

*.enableMecOperatorB = true

# MEC host A handles operator A's gNBs
# MEC host B handles operator B's gNBs
*.mecHost_A*.bsList = "gnb_A1, gnb_A2, gnb_A3, gnb_A4"
*.mecHost_B*.bsList = "gnb_B1, gnb_B2, gnb_B3, gnb_B4"

*.mecHost_A.independentMecApp[0].federatedProducerApps = [{id : 1, address: "mecHost_B.virtualisationInfrastructure", port: 8500, \
											   locationServiceAddress: "mecHost_B.virtualisationInfrastructure", locationServicePort: 10020}]
*.mecHost_B.independentMecApp[0].federatedProducerApps = [{id : 0, address: "mecHost_A.virtualisationInfrastructure", port: 8500, \
											   locationServiceAddress: "mecHost_A.virtualisationInfrastructure", locationServicePort: 10020}]

#------------UEPlatooningApp---------------
*.ue*[*].numApps = 2
*.ue*[*].app[0].typename = "DeviceApp"
*.ue*[*].app[0].localPort = 4500
*.ue_A[*].app[0].UALCMPAddress = "ualcmp_A"
*.ue_B[*].app[0].UALCMPAddress = "ualcmp_B"
*.ue*[*].app[0].UALCMPPort = 1000


*.ue*[*].app[1].typename = "UEPlatooningApp"
*.ue_A[*].app[1].deviceAppAddress = "ue_A["+string(ancestorIndex(1))+"]"
*.ue_B[*].app[1].deviceAppAddress = "ue_B["+string(ancestorIndex(1))+"]"
*.ue*[*].app[1].deviceAppPort = 4500


# delay starTime to force correct order
*.ue_A[0].app[1].startTime = 1s
*.ue_A[1].app[1].startTime = 1.2s
*.ue_A[2].app[1].startTime = 1.3s
*.ue_A[3].app[1].startTime = 1.4s
*.ue_B[0].app[1].startTime = 2.2s 
*.ue_B[1].app[1].startTime = 2.3s 
*.ue_B[2].app[1].startTime = 2.4s 
*.ue_B[3].app[1].startTime = 2.5s 

#*.ue_A[2].app[1].leaveTime = 11s
*.ue*[*].app[1].leaveTime = 45s
*.ue*[*].app[1].stopTime = 150s		
*.ue*[*].app[1].positionX = 800	
*.ue*[*].app[1].positionY = 600
#------------------------------------#

# In this configuration Location services vary the service time. Cars of different operators will have
# position updates NOT synchronised
[Config MultiOperator_MultiMec_LoadAandB]
extends = MultiOperator_MultiMec
repeat = 1
*.mecHost_A.mecPlatform.mecService[0].requestServiceTime = ${stA = 0.5, 5..30 step 5}ms
*.mecHost_B.mecPlatform.mecService[0].requestServiceTime = ${stB = 0.5, 5..30 step 5}ms

# In this configuration Location services vary the service time. Cars of different operators will have
# position updates NOT synchronised but ADJUSTED by the MEC Controller App
[Config MultiOperator_MultiMec_LoadAandB_adjustment]
extends=MultiOperator_MultiMec_LoadAandB
**.adjustPosition = true

# In this configuration Location services vary the service time. Cars of different operators will have
# position updates NOT synchronised. The platoon leader proceeds in a sinusoidal manner
[Config MultiOperator_MultiMec_LoadAandB_sinusoidal]
extends=MultiOperator_MultiMec_LoadAandB
*.ue_A[0].app[1].sinusoidal = true


# In this configuration Location services vary the service time. Cars of different operators will have
# position updates NOT synchronised but ADJUSTED by the MEC Controller App
# The platoon leader proceeds in a sinusoidal manner
[Config MultiOperator_MultiMec_LoadAandB_sinusoidal_adjustment]
extends=MultiOperator_MultiMec_LoadAandB
*.ue_A[0].app[1].sinusoidal = true
**.adjustPosition = true

# In this configuration Location services vary the service time AND a delay bewteen the two MEC systems is present. 
# Cars of different operators will have position updates NOT synchronised
[Config MultiOperator_MultiMec_propDelay_LoadAandB]
extends = MultiOperator_MultiMec
repeat = 1
#*.mecHost_*.mecPlatform.mecService[0].requestServiceTime = ${st = 1, 5..30 step 5}ms
*.mecHost_A.mecPlatform.mecService[0].requestServiceTime = ${stA = 0.5, 5, 10, 20, 30}ms
*.mecHost_B.mecPlatform.mecService[0].requestServiceTime = ${stB = 0.5, 5, 10, 20, 30}ms
*.linkLength = ${delay = 0, 1, 5, 10..50 step 10}m #is ms
**.tcp.mss = 1452
**.nagleEnabled = false

# In this configuration Location services vary the service time AND a delay bewteen the two MEC systems is present. 
# Cars of different operators will have position updates NOT synchronised but ADJUSTED by the MEC Controller App
[Config MultiOperator_MultiMec_propDelay_LoadAandB_adjustment]
extends=MultiOperator_MultiMec_propDelay_LoadAandB
**.adjustPosition = true

# In this configuration Location services vary the service time AND a delay bewteen the two MEC systems is present. 
# Cars of different operators will have position updates NOT synchronised but ADJUSTED by the MEC Controller App
# The platoon leader proceeds in a sinusoidal manner
[Config MultiOperator_MultiMec_propDelay_LoadAandB_adj_sinusoidal]
extends=MultiOperator_MultiMec_propDelay_LoadAandB_adjustment
*.ue_A[0].app[1].sinusoidal = true

# In this configuration Location services vary the service time AND a delay bewteen the two MEC systems is present. 
# Cars of different operators will have position updates NOT synchronised
# The platoon leader proceeds in a sinusoidal manner
[Config MultiOperator_MultiMec_propDelay_LoadAandB_sinusoidal]
extends = MultiOperator_MultiMec_propDelay_LoadAandB
*.ue_A[0].app[1].sinusoidal = true

# In this configuration a platoon is formed of 15 cars (3 of A and 12 of B operator). It used t count the number of instructions
# needed by the control algorithm to compute the new acceleration values
[Config MultiOperator_MultiMec_instruction_count]
extends = MultiOperator_MultiMec
repeat = 1
*.mecHost_*.mecPlatform.mecService[0].requestServiceTime = 0.5ms
# platoon for instructions calculation
*.numUe_B = 12

*.ue_B[4].app[1].startTime = 5.2s 
*.ue_B[5].app[1].startTime = 5.3s 
*.ue_B[6].app[1].startTime = 5.4s 
*.ue_B[7].app[1].startTime = 5.5s 
*.ue_B[8].app[1].startTime = 5.6s 
*.ue_B[9].app[1].startTime = 5.7s 
*.ue_B[10].app[1].startTime = 5.8s 
*.ue_B[11].app[1].startTime = 5.9s 

# In this configuration cars platoon quickly converges and the MEC controller app goes in CRUISE mode sooner
[Config MultiOperator_MultiMec_Cruise]
extends=MultiOperator_MultiMec

*.ue_A[0].mobility.initialX = 310m
*.ue_A[1].mobility.initialX = 300m
*.ue_A[2].mobility.initialX = 290m
*.ue_B[0].mobility.initialX = 280m
*.ue_B[1].mobility.initialX = 270m
			

#------------------------------------#

# In this configuration cars slowly join the platoon and the MEC controller app performs longer join maneuver 
# and a leave maneuver in the middle of platoon for car A[2]
[Config MultiOperator_MultiMec_Validation]
extends=MultiOperator_MultiMec

*.ue_A[2].app[1].leaveTime = 40s
*.ue*[*].app[1].leaveTime = 55s
*.ue*[*].app[1].stopTime = 60s	

*.ue_A[0].app[1].startTime = 1s
*.ue_A[1].app[1].startTime = 1.2s
*.ue_A[2].app[1].startTime = 1.3s
*.ue_A[3].app[1].startTime = 1.4s
*.ue_B[0].app[1].startTime = 2.0s 
*.ue_B[1].app[1].startTime = 2.1s 
*.ue_B[2].app[1].startTime = 2.2s 
*.ue_B[3].app[1].startTime = 2.3s 

*.ue_A[0].mobility.initialX = 230m
*.ue_A[1].mobility.initialX = 200m
*.ue_A[2].mobility.initialX = 190m
*.ue_A[3].mobility.initialX = 182m
*.ue_B[0].mobility.initialX = 178m
*.ue_B[1].mobility.initialX = 160m
*.ue_B[2].mobility.initialX = 155m
*.ue_B[3].mobility.initialX = 145m


# ----------------------------------------------------------------------------------------------------- #
# MultiOperator_SingleMec
#
# In this configuration, UEs connected to operator A's network AND UEs connected to operator B's network  
# communicate with operator A's MEC Host
#
[Config MultiOperator_SingleMec]
extends=MultiOperator

*.enableMecOperatorB = false

# MEC host A handles operator A's and operator B's gNBs
*.mecHost_A*.bsList = "gnb_A1, gnb_A2, gnb_A3, gnb_A4, gnb_B1, gnb_B2, gnb_B3, gnb_B4"

#------------UEPlatooningApp---------------
*.ue*[*].numApps = 2
*.ue*[*].app[0].typename = "DeviceApp"
*.ue*[*].app[0].localPort = 4500
*.ue*[*].app[0].UALCMPAddress = "ualcmp_A"
*.ue*[*].app[0].UALCMPPort = 1000

*.ue*[*].app[1].typename = "UEPlatooningApp"
*.ue_A[*].app[1].deviceAppAddress = "ue_A["+string(ancestorIndex(1))+"]"
*.ue_B[*].app[1].deviceAppAddress = "ue_B["+string(ancestorIndex(1))+"]"
*.ue*[*].app[1].deviceAppPort = 4500
*.ue*[*].app[1].controllerIndex = 0

*.ue_A[0].app[1].startTime = 4s
*.ue_A[1].app[1].startTime = 4.2s
*.ue_A[2].app[1].startTime = 4.3s
*.ue_B[0].app[1].startTime = 4.6s 
*.ue_B[1].app[1].startTime = 4.9s 	
*.ue*[*].app[1].joinTime = 1s
*.ue*[*].app[1].leaveTime = uniform(30s,31s)				
*.ue*[*].app[1].stopTime = uniform(35s,36s)
#------------------------------------#